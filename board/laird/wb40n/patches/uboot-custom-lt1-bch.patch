--- a/drivers/mtd/nand/atmel_nand.c
+++ b/drivers/mtd/nand/atmel_nand.c
@@ -1010,7 +1010,7 @@
 	mtd->priv = nand;
 	nand->IO_ADDR_R = nand->IO_ADDR_W = (void  __iomem *)base_addr;
 
-	nand->ecc.mode = NAND_ECC_SOFT;
+	nand->ecc.mode = NAND_ECC_SOFT_BCH;
 #ifdef CONFIG_SYS_NAND_DBW_16
 	nand->options = NAND_BUSWIDTH_16;
 #endif
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -873,29 +873,52 @@
 static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
 				uint8_t *buf, int page)
 {
-	int i, eccsize = chip->ecc.size;
-	int eccbytes = chip->ecc.bytes;
-	int eccsteps = chip->ecc.steps;
+	int i, eccsize;
+	int eccbytes;
+	int eccsteps;
+	int eccszdiff;
 	uint8_t *p = buf;
 	uint8_t *ecc_calc = chip->buffers->ecccalc;
 	uint8_t *ecc_code = chip->buffers->ecccode;
-	uint32_t *eccpos = chip->ecc.layout->eccpos;
+	struct nand_ecc_ctrl *ecc = &chip->ecc;
+	uint32_t *eccpos = ecc->layout->eccpos;
 
 	chip->ecc.read_page_raw(mtd, chip, buf, page);
 
-	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
-		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+	if (chip->ecc.mode == NAND_ECC_SOFT_BCH) {
+		eccszdiff = chip->ecc.total - chip->ecc_ham.total;
+		for (i = 0; i < eccszdiff; i++) {
+			if (chip->oob_poi[eccpos[i]] != 0xff)
+				break;
+		}
+
+		if (i >= eccszdiff)
+			ecc = &chip->ecc_ham;
+	}
+
+retry:
+	eccsize = ecc->size;
+	eccbytes = ecc->bytes;
+	eccsteps = ecc->steps;
+	eccpos = ecc->layout->eccpos;
 
-	for (i = 0; i < chip->ecc.total; i++)
+	for (i = 0; i < ecc->total; i++)
 		ecc_code[i] = chip->oob_poi[eccpos[i]];
 
-	eccsteps = chip->ecc.steps;
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
+		ecc->calculate(mtd, p, &ecc_calc[i]);
+
+	eccsteps = ecc->steps;
 	p = buf;
 
 	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 		int stat;
 
-		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
+		stat = ecc->correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
+		if (stat < 0 && ecc == &chip->ecc) {
+			ecc = &chip->ecc_ham;
+			goto retry;
+		}
 		if (stat < 0)
 			mtd->ecc_stats.failed++;
 		else
@@ -2947,19 +2970,27 @@
 	/*
 	 * If no default placement scheme is given, select an appropriate one
 	 */
-	if (!chip->ecc.layout && (chip->ecc.mode != NAND_ECC_SOFT_BCH)) {
+	if (!chip->ecc.layout) {
 		switch (mtd->oobsize) {
 		case 8:
-			chip->ecc.layout = &nand_oob_8;
+			if (chip->ecc.mode != NAND_ECC_SOFT_BCH)
+				chip->ecc.layout = &nand_oob_8;
+			chip->ecc_ham.layout = &nand_oob_8;
 			break;
 		case 16:
-			chip->ecc.layout = &nand_oob_16;
+			if (chip->ecc.mode != NAND_ECC_SOFT_BCH)
+				chip->ecc.layout = &nand_oob_16;
+			chip->ecc_ham.layout = &nand_oob_16;
 			break;
 		case 64:
-			chip->ecc.layout = &nand_oob_64;
+			if (chip->ecc.mode != NAND_ECC_SOFT_BCH)
+				chip->ecc.layout = &nand_oob_64;
+			chip->ecc_ham.layout = &nand_oob_64;
 			break;
 		case 128:
-			chip->ecc.layout = &nand_oob_128;
+			if (chip->ecc.mode != NAND_ECC_SOFT_BCH)
+				chip->ecc.layout = &nand_oob_128;
+			chip->ecc_ham.layout = &nand_oob_128;
 			break;
 		default:
 			printk(KERN_WARNING "No oob scheme defined for "
@@ -3080,6 +3111,18 @@
 		if (!chip->ecc.priv)
 			printk(KERN_WARNING "BCH ECC initialization failed!\n");
 
+		chip->ecc_ham.calculate = nand_calculate_ecc;
+		chip->ecc_ham.correct = nand_correct_data;
+		chip->ecc_ham.read_page = nand_read_page_swecc;
+		chip->ecc_ham.read_subpage = nand_read_subpage;
+		chip->ecc_ham.write_page = nand_write_page_swecc;
+		chip->ecc_ham.read_page_raw = nand_read_page_raw;
+		chip->ecc_ham.write_page_raw = nand_write_page_raw;
+		chip->ecc_ham.read_oob = nand_read_oob_std;
+		chip->ecc_ham.write_oob = nand_write_oob_std;
+		chip->ecc_ham.size = 256;
+		chip->ecc_ham.bytes = 3;
+		chip->ecc_ham.mode = NAND_ECC_SOFT;
 		break;
 
 	case NAND_ECC_NONE:
@@ -3112,6 +3155,14 @@
 			chip->ecc.layout->oobfree[i].length;
 	mtd->oobavail = chip->ecc.layout->oobavail;
 
+	if (chip->ecc.mode == NAND_ECC_SOFT_BCH) {
+		chip->ecc_ham.layout->oobavail = 0;
+		for (i = 0; chip->ecc_ham.layout->oobfree[i].length
+				&& i < ARRAY_SIZE(chip->ecc_ham.layout->oobfree); i++)
+			chip->ecc_ham.layout->oobavail +=
+				chip->ecc_ham.layout->oobfree[i].length;
+	}
+
 	/*
 	 * Set the number of read / write steps for one page depending on ECC
 	 * mode
@@ -3122,6 +3173,11 @@
 		BUG();
 	}
 	chip->ecc.total = chip->ecc.steps * chip->ecc.bytes;
+
+	if (chip->ecc.mode == NAND_ECC_SOFT_BCH) {
+		chip->ecc_ham.steps = mtd->writesize / chip->ecc_ham.size;
+		chip->ecc_ham.total = chip->ecc_ham.steps * chip->ecc_ham.bytes;
+	}
 
 	/*
 	 * Allow subpage writes up to ecc.steps. Not possible for MLC
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -530,6 +530,7 @@
 	struct nand_hw_control *controller;
 	struct nand_ecclayout *ecclayout;
 
+	struct nand_ecc_ctrl ecc_ham;
 	struct nand_ecc_ctrl ecc;
 	struct nand_buffers *buffers;
 	struct nand_hw_control hwcontrol;
 
