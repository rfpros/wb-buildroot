diff --git a/hostapd/main.c b/hostapd/main.c
index a9d91b9..ac319a1 100644
--- a/hostapd/main.c
+++ b/hostapd/main.c
@@ -282,6 +282,36 @@ static int handle_reload_iface(struct hostapd_iface *iface, void *ctx)
 	return 0;
 }
 
+int hostapd_reconfig_iface(struct hostapd_iface *iface, void *ctx)
+{
+	const struct wpa_driver_ops *driver;
+	void *drv_priv;
+
+	if (iface == NULL)
+		goto fail;
+
+	driver = iface->bss[0]->driver;
+	drv_priv = iface->bss[0]->drv_priv;
+	hostapd_interface_deinit(iface);
+	if (driver && driver->hapd_deinit && drv_priv)
+		driver->hapd_deinit(drv_priv);
+
+	if (iface->conf->bss[0]->iface[0] != 0 ||
+	    hostapd_drv_none(iface->bss[0])) {
+		if (hostapd_driver_init(iface) || hostapd_setup_interface(iface)) {
+			hostapd_interface_deinit_free(iface);
+			goto fail;
+		}
+	} else
+		goto fail;
+
+	return 0;
+
+fail:
+	wpa_printf(MSG_WARNING, "Failed to reconfigure driver and "
+	           "interface.");
+	return 0;
+}
 
 /**
  * handle_reload - SIGHUP handler to reload configuration
@@ -294,6 +324,16 @@ static void handle_reload(int sig, void *signal_ctx)
 	hostapd_for_each_interface(interfaces, handle_reload_iface, NULL);
 }
 
+/**
+ * handle_reconfig_ifaces - SIGUS2 handler to reconfigure drivers and interfaces
+ */
+static void handle_reconfig_ifaces(int sig, void *signal_ctx)
+{
+	struct hapd_interfaces *interfaces = signal_ctx;
+	wpa_printf(MSG_DEBUG, "Signal %d received - reconfiguring drivers and interfaces",
+		   sig);
+	hostapd_for_each_interface(interfaces, hostapd_reconfig_iface, NULL);
+}
 
 static void handle_dump_state(int sig, void *signal_ctx)
 {
@@ -326,6 +366,7 @@ static int hostapd_global_init(struct hapd_interfaces *interfaces,
 #ifndef CONFIG_NATIVE_WINDOWS
 	eloop_register_signal(SIGHUP, handle_reload, interfaces);
 	eloop_register_signal(SIGUSR1, handle_dump_state, interfaces);
+	eloop_register_signal(SIGUSR2, handle_reconfig_ifaces, interfaces);
 #endif /* CONFIG_NATIVE_WINDOWS */
 	eloop_register_signal_terminate(handle_term, interfaces);
 
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index d030474..8f5f1c4 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -26,6 +26,7 @@
 #include <netpacket/packet.h>
 #include <linux/filter.h>
 #include <linux/errqueue.h>
+#include <signal.h>
 #include "nl80211_copy.h"
 
 #include "common.h"
@@ -352,6 +353,7 @@ struct wpa_driver_nl80211_data {
 	int auth_p2p;
 };
 
+static unsigned int reg_change_seen = 0;
 
 static void wpa_driver_nl80211_deinit(struct i802_bss *bss);
 static void wpa_driver_nl80211_scan_timeout(void *eloop_ctx,
@@ -3196,6 +3198,17 @@ static void do_process_drv_event(struct i802_bss *bss, int cmd,
 		nl80211_cqm_event(drv, tb);
 		break;
 	case NL80211_CMD_REG_CHANGE:
+		/* On start a regulatory domain change event should happen.
+		 * If another REG_CHANGE event happens, it likely means the
+		 * firmware restarted. So send a signal to ourselves to
+		 * reconfigure the driver and interface.
+		 */
+		if(reg_change_seen) {
+			reg_change_seen = 0;
+			raise(SIGUSR2);
+		} else {
+			reg_change_seen = 1;
+		}
 		nl80211_reg_change_event(drv, tb);
 		break;
 	case NL80211_CMD_REG_BEACON_HINT:
